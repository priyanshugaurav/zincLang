fn main() {
// 1 - numeric unify
var a = [1, 2.0, 3]; // => array<float>

// 2 - heterogeneous -> any
var b = [1,"s",3]; // => array<any>

// 3 - empty default
var c = []; // => array<any>

// 4 - typed widen (non-strict)
var d: array<int> = [1, "x"]; // => allowed, variable type becomes array<any>

// 5 - strict error
var e: strict array<int> = [1, "x"]; // => Type Error

// 6 - nullable element inference
var f = [null, 1]; // => array<int?>

// 7 - assign null to nullable element
var g: array<int?> = [1,2];
g[1] = null; // OK

// 8 - assign null to non-nullable element
var h: array<int> = [1,2];
h[1] = null; // Type Error

// 9 - nested nullable assign (your failing case)
var i: array<array<float?>?>;
i[0] = null; // OK after patch
i[0] = [1.1, null, 2.2]; // OK
i[1][11] = 3.3; // Compile-time Type Error: i[1] is nullable

// 10 - index out of bounds (compile-time)
var j = [1,2,3];
j[3] = 4; // Compile-time error

// 11 - let immutable
let k = [1,2];
k = [1]; // Error: cannot assign to let

}
