üèóÔ∏è Language Design Plan (Updated)

Your language = fastest, safe by default, flexible when needed.
Two modes:

Strict Mode ‚Üí strong typing, no silent conversions, null must be explicit (T?)

Dynamic Mode ‚Üí looser typing, variables can change type, null allowed freely

1Ô∏è‚É£ Entry Point
fn main() {
    // program starts here
}

2Ô∏è‚É£ Variables & Types
Declaration
let a: int = 10      // strict type
let b = "hello"      // inferred type
var c = 20           // mutable variable


let ‚Üí immutable by default (safe, like Rust)

var ‚Üí mutable

Type annotations optional if inference works

Core Types

int (64-bit signed by default)

float (64-bit double precision)

bool (true / false)

string (UTF-8)

null (only allowed via optional types in strict mode)

T? (optional type ‚Üí safe nullable)

array<T>

map<K, V>

fn (functions as first-class values)

struct (user-defined types)

Null & Optionals
let x: int? = null     // optional integer
let y: string? = "hi"  

if y != null {
    print(y)           // safe use
}
print(y?)              // shorthand safe print


Dynamic mode:

let z = "hello"
z = null   // allowed, becomes optional automatically

3Ô∏è‚É£ Expressions

Arithmetic: + - * / %

Comparison: == != < > <= >=

Boolean: && || !

String concatenation: "hi" + " world"

Array access: arr[0]

Map access: map["key"]

4Ô∏è‚É£ Statements & Control Flow
If Expression
let grade = if score > 90 { "A" } else { "B" }

If Statement
if a > 10 {
    print("big")
} else {
    print("small")
}

While
while i < 10 {
    print(i)
    i = i + 1
}

For (iterator-based)
for x in [1,2,3] {
    print(x)
}

Times (repeat N times)
5 times {
    print("Hello")
}

5Ô∏è‚É£ Functions
Declaration
fn add(a:int, b:int): int {
    return a + b
}

First-class
let f: fn(int)->int = add
print(f(10))

Optional Return
fn findUser(id:int): User? {
    if id == 0 { return null }
    return User("ok")
}

6Ô∏è‚É£ Scope & Environment

Block-scoped ‚Üí {} introduces new scope

Variables shadow outer ones safely

Environment = stack of symbol tables

Global

Function scope

Block scope

7Ô∏è‚É£ Type System Modes
Strict Mode
let a: int = 10
a = "hello"   // ‚ùå compile error

Dynamic Mode
let b = 10
b = "hello"   // ‚úÖ allowed, type changes